## 诊断结论
- 前端调用链与错误展示逻辑正确；Axios 统一体解析与凭证携带设置合理。
- 后端登录正常路径仅返回 200/401/422，出现 500 说明有未捕获的运行时异常（数据库/映射/空指针等）。
- 代码关键路径：
  - `AuthController.login` 读取用户并校验密码（com/lyx/secondhandsystem/controller/AuthController.java:54-75）。
  - 用户查询：`UserServiceImpl.getByUsername` 走 MyBatisPlus 默认映射（com/lyx/secondhandsystem/service/impl/UserServiceImpl.java:33-37）。
  - 全局异常仅处理 `MethodArgumentNotValidException(422)` 与 `IllegalArgumentException(400)`（com/lyx/secondhandsystem/common/GlobalExceptionHandler.java:16-37）。
- 高概率根因：
  1) 数据库异常（表/列不匹配、连接失败）导致 `PersistenceException` → 500。
  2) 用户数据异常（`password_hash` 为空或非 BCrypt 格式）触发第三方库异常未被捕获。
  3) 其他运行时异常未被统一处理，落到默认 500。

## 验证步骤（无代码改动）
1) 用同样 payload 直接 `curl` 复现：`curl -i -X POST http://localhost:8080/api/auth/login -H "Content-Type: application/json" -d '{"username":"alice","password":"123456"}'`，确认后端实际 HTTP 状态与响应体。
2) 检查后端日志堆栈（异常类型、SQL、表名/列名）。
3) 检查 `users` 表结构与实体：是否包含 `password_hash/nickname/role`，字段类型与大小写匹配（参考 com/lyx/secondhandsystem/entity/User.java:21-38）。
4) 检查目标用户的 `password_hash` 是否为 BCrypt（以 `$2a$`/`$2b$` 前缀），避免 `matches` 抛异常。

## 修复方案（需你确认后执行）
1) 统一兜底异常处理：在 `GlobalExceptionHandler` 增加 `@ExceptionHandler(Exception.class)` 返回 `500` 的统一体，带简化错误信息，避免非预期 HTML 错误页。
2) 登录流程稳健化：在 `AuthController.login` 中对 `u.getPasswordHash()==null` 或格式异常时，统一走 401（“密码错误”），避免外部库异常外泄。
3) 增加关键日志：登录失败时打印用户名与失败原因（不打印明文密码），便于定位。
4) 校验并修正数据库：确保 `users(password_hash)` 列存在且类型为 `varchar`，现有测试用户密码用注册接口重新生成 BCrypt 哈希。
5) 可选：增加 CORS（若前后端不走 dev proxy）统一允许指定来源并允许凭证，以避免真实联调时跨域问题。

## 交付内容
- 代码层面：新增兜底异常处理、增强登录空值与格式校验、必要日志；不改变既有接口签名与响应结构。
- 文档层面：补充错误码 `403`（管理员权限），添加“跨域与凭证”说明一节。

请确认是否按该方案修改代码与文档；确认后我将一次性完成实现与验证。